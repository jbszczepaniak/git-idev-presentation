<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>git presentation</title>
		<link rel="shortcut icon" href="git_logo.png">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
				<h1>About git</h1>
				<h2 class="fragment">for collegaues</h2>
				<h2 class="fragment">from idevelopment.pl</h2>
				</section>
				<section>
					<section>
						<h2>First important thing</h2>
						<h3>Which I think is useful</h3>
					</section>
					<section>
						<p>add following to your ~/.bashrc file</p>
							<pre><code data-trim data-noescape class="bash">
								parse_git_branch()
								{git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'}
								export PS1="\u@\h \[\033[32m\]\w\[\033[33m\]\$(parse_git_branch)\[\033[00m\] $ "
							</code></pre>
					</section>
					<section>
						and your terminal prompt will change from:
						<pre><code data-trim data-noescape>
						$
						</code></pre>
						into:
						<pre><code data-trim data-noescape>
						(branchname)$
						</code></pre>
					</section>
					<section>
						good practise in local environment !
					</section>
					<section>
						and must have on production server !
					</section>
				</section>
				<section>
					<section>
						<h2>Create new repository</h2>
					</section>

					<section>
						Create a folder and go to it.
						<pre>
							<code data-trim data-noescape class="bash">
								~ $ mkdir presentation
								~ $ cd presentation/
 							</code>
 						</pre>
 						initialize empty git repository
 						<pre>
 							<code data-trim data-noescape class="bash">
								~/presentation $ git init
								Initialized empty Git repository in /home/jedrzej/presentation/.git/
							</code>
						</pre>
					</section>
					<section>
						create .gitignore file
						<pre>
							<code data-trim data-noescape>
	 							~/presentation $ touch .gitignore
	 						</code>
	 					</pre>
	 					check status of repository
	 					<pre>
	 						<code data-trim data-noescape class="bash">
	 					~/presentation $ git status
							On branch master
							Initial commit
							Untracked files:
							(use "git add <file>..." to include in what will be committed)
							.gitignore
							nothing added to commit but untracked files present (use "git add" to track)
							</code>
						</pre>
					</section>
					<section>
						add .gitignore to existing repository
						<pre>
							<code data-trim data-noescape class="bash">
								~/presentation $ git add .gitignore
								~/presentation $ git commit -m "Initial commit with .gitignore file"
								[master (root-commit) d12a8a1] Initial commit with .gitignore file
								1 file changed, 0 insertions(+), 0 deletions(-)
								create mode 100644 .gitignore
							</code>
						</pre>
					</section>
					<section>
						check logs in repository
						<pre>
							<code data-trim data-noescape  class="bash">
							~/presentation (master) $ git log
							commit d12a8a1ed12c6f9615eed96caa54dec5d4b7e4e7
							Author: jedrzej <jedrzej@szczepaniak.com>
							Date:   Thu Feb 9 21:47:11 2017 +0100

							Initial commit with .gitignore file

							</code>
						</pre>
					</section>
				</section>
				<section >
					<section>
						<h4>Let's create remote repository</h4>
						<h4>on local machine just for sake of this presentation</h4>
						<p>because it is not really important, wheter it sits on github.com, gitlab.com, bitbucket.com, or in another directory on local machine</p>
					</section>
					<section>
						let's create new directory and go to this directory.
						<pre>
							<code data-trim data-noescape  class="bash">
							~ $ mkdir presentation-remote
							~ $ cd presentation-remote
							</code>
						</pre>
					</section>
					<section>
						Now we will create <mark>bare repository</mark>.
						Bare repository does not have checked out working tree, which means that in this repository, we don't have any source code. We have only the state of git repository.
						<pre>
							<code data-trim data-noescape  class="bash">
							~/presentation-remote $ git init --bare
							Initialized empty Git repository in /home/jedrzej/presentation-remote/
							</code>
						</pre>
					</section>
					<section>
						<p>content of bare repository is different than content of regular repository.</p>
						<p>There is no .git directory, all of the informations are kept in special directories</p>
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation-remote $ ls -a
							.  ..  branches  config  description  HEAD  hooks  info  objects  refs
							</code>
						</pre>
					</section>
					<section>
						<p>last one step, we should tell our local repository about remote repository</p>
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (master) $ git remote add origin ../presentation-remote/
							</code>
						</pre>
						<p>and that we want our local master branch to track remote master branch</p>
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (master) $ git branch --set-upstream-to=origin/master master
							Branch master set up to track remote branch master from origin.
							</code>
						</pre>
					</section>
					<section>
						<p>we can do some verification</p>
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (master) $ git remote -vvv
							origin	../presentation-remote/ (fetch)
							origin	../presentation-remote/ (push)
							</code>
						</pre>
						-vvv means be as verbose as you can.

						<pre>
							<code data-trim data-noescape  class="hljs">
							jedrzej@jedrzej-UX303LB ~/presentation (master) $ git remote show origin
							* remote origin
							  Fetch URL: ../presentation-remote/
							  Push  URL: ../presentation-remote/
							  HEAD branch: master
							  Remote branches:
							    master            tracked
							  Local branch configured for 'git pull':
							    master merges with remote master
							  Local ref configured for 'git push':
							    master pushes to master (up to date)
							</code>
						</pre>

					</section>
					<section>
						<h4>Note!</h4>
						<p>Normally we work with non-bare repositories. They have source code in them, and .git directory which keeps all the git related information</p>
						<p>In bare repositories we don't have source code. They exist to put them on the server when you don't use any public repository.</p>
					</section>
				</section>
				<section>
					<section>
						let's create new branch
					</section>
					<section>
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (master) $ git checkout -b "create-readme"
							Switched to a new branch 'create-readme'
							</code>
						</pre>
						equivalent version of the same output would be
						<pre>
							<code data-trim data-noescape  class="bash">
							~/presentation (master) $ git branch create-readme
							~/presentation (master) $ git checkout create-readme
							Switched to branch 'create-readme'
							</code>
						</pre>
					</section>
					<section>
						let's create readme
						<pre>
							<code data-trim data-noescape  class="bash">
							~/presentation (create-readme) $ touch README.md
							~/presentation (create-readme) $ echo "This is readme.md" > README.md
							</code>
						</pre>
						add it to repository
						<pre>
							<code data-trim data-noescape  class="bash">
							~/presentation (create-readme) $ git add README.md
							~/presentation (create-readme) $ git status
							On branch create-readme
							Changes to be committed:
							  (use "git reset HEAD <file>..." to unstage)

								new file:   README.md
							</code>
						</pre>
					</section>
					<section>
						and commit it
						<pre>
							<code data-trim data-noescape  class="bash">
							~/presentation (create-readme) $ git commit -m "Create readme file"
							[create-readme f8e6e63] Create readme file
							 1 file changed, 1 insertion(+)
							 create mode 100644 README.md
							</code>
						</pre>
					</section>
					<section>
						now we want to go back to master branch, and merge changes from create-readme branch
						<pre>
							<code data-trim data-noescape  class="bash">
							~/presentation (create-readme) $ git checkout master
							Switched to branch 'master'
							Your branch is up-to-date with 'origin/master'.
							~/presentation (master) $ git merge create-readme
							Updating d12a8a1..f8e6e63
							Fast-forward
							 README.md | 1 +
							 1 file changed, 1 insertion(+)
							 create mode 100644 README.md
							</code>
						</pre>
					</section>
					<section>
						let's push those changes to remote
						<pre>
							<code data-trim data-noescape  class="bash">
							~/presentation (master) $ git push
							Counting objects: 6, done.
							Delta compression using up to 4 threads.
							Compressing objects: 100% (3/3), done.
							Writing objects: 100% (6/6), 493 bytes | 0 bytes/s, done.
							Total 6 (delta 0), reused 0 (delta 0)
							To ../presentation-remote/
							 * [new branch]      master -> master
							</code>
						</pre>
					</section>
					<section>
						suddenly, remote repository knows about new branch - master, because we pushed it to remote.
						<pre>
							<code data-trim data-noescape  class="bash">
							~/presentation-remote $ git branch
							* master
							</code>
						</pre>
					</section>
					<section>
						From perspective of local repository, the remote repository is called origin. It is a convention. It could have any other name, we just explicitly told that we want to name it origin via
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (master) $ git remote add origin ../presentation-remote/
							</code>
						</pre>
						That is why from local perspective, the remote branch master is <mark>origin/master</mark>
						</section>
						<section>
							<p>We use origin by default always when we clone repository.</p>
							<p>git assumes that we will want refer to remote repository in the future and it automatically sets remote repository for us, and calls it <mark>origin</mark>.</p>
						</section>
						<section>
							<p>let's check</p>
							<pre>
								<code data-trim data-noescape  class="bash">
								~ $ git clone git@github.com:jedruniu/git-idev-presentation.git
								Cloning into 'git-idev-presentation'...
								remote: Counting objects: 150, done.
								remote: Compressing objects: 100% (113/113), done.
								remote: Total 150 (delta 35), reused 145 (delta 30), pack-reused 0
								Receiving objects: 100% (150/150), 2.66 MiB | 1.19 MiB/s, done.
								Resolving deltas: 100% (35/35), done.
								Checking connectivity... done.
								~ $ cd git-idev-presentation/
								~/git-idev-presentation (master) $ git remote -vvv
								origin	git@github.com:jedruniu/git-idev-presentation.git (fetch)
								origin	git@github.com:jedruniu/git-idev-presentation.git (push)
								~/git-idev-presentation (master) $
								</code>
							</pre>
						</section>
						<section>
							now we decided that we don't need create-readme branch anymore
							to remove local branch we run
							<pre>
								<code data-trim data-noescape  class="hljs">
								~/presentation (master) $ git branch -d create-readme
								Deleted branch create-readme (was f8e6e63).
								</code>
							</pre>
						</section>
						<section>
							someone creates branch in remote repository
							<pre>
								<code data-trim data-noescape  class="hljs">
								~/presentation-remote (master) $ git branch new-functionality
								~/presentation-remote (master) $ git branch
								* master
								  new-functionality
								</code>
							</pre>
						</section>
						<section>
							we do git pull do make sure that our local repository is up to date
							<pre>
								<code data-trim data-noescape  class="hljs">
								~/presentation (master) $ git pull
								From ../presentation-remote
								 * [new branch]      new-functionality -> origin/new-functionality
								Already up-to-date.
								</code>
							</pre>
							and we figure out that new branch was added remotely.
						</section>
						<section>
							But we don't like this branch very much and we would like to deleted it. We can.
							<pre>
								<code data-trim data-noescape  class="hljs">
								~/presentation (master) $ git push origin :new-functionality
								To ../presentation-remote/
								 - [deleted]         new-functionality
								</code>
							</pre>
							Now on the remote repository new-functionality branch is gone
							<pre>
								<code data-trim data-noescape  class="hljs">
								~/presentation-remote (master) $ git branch
								* master
								</code>
							</pre>
						</section>
					</section>

				<section>
					<section>
						rebasing
					</section>
					<section>
						we create locally new branch called statistics, and commit some file in it
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (master) $ git checkout -b statistics
							Switched to a new branch 'statistics'
							~/presentation (statistics) $ echo "Statistics code" > stats.c
							~/presentation (statistics) $ git add stats.c
							~/presentation (statistics) $ git commit -m "core statistics file"
							[statistics 38a45e9] core statistics file
							 1 file changed, 1 insertion(+)
							 create mode 100644 stats.c
							</code>
						</pre>
					</section>
					<section>
						then we go back to master and change something in README.md
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (statistics) $ git checkout master
							Switched to branch 'master'
							Your branch is up-to-date with 'origin/master'.
							~/presentation (master) $ echo "new line in readme" >> README.md
							~/presentation (master) $ git add README.md
							~/presentation (master) $ git commit -m "Readme update"
							[master d672e93] Readme update
							 1 file changed, 1 insertion(+)
							</code>
						</pre>
					</section>
					<section>
						now our repository looks like this:
						<pre>
							<code data-trim data-noescape  class="hljs">
								~/presentation (master) $ git lg
								* d672e93 - (2 minutes ago) Readme update - jedrzej (HEAD -> master)
								| * 38a45e9 - (5 minutes ago) core statistics file - jedrzej (statistics)
								|/
								* f8e6e63 - (2 days ago) Create readme file - jedrzej (origin/master)
								* d12a8a1 - (4 days ago) Initial commit with .gitignore file - jedrzej
							</code>
						</pre>
						for graph git log Google something like "pretty git log"
					</section>
					<section>
						now if we want to have changes from statistics branch in master branch we can do merge.
						<pre>
							<code data-trim data-noescape  class="hljs">
							(f8e6e63)------(d672e93)
								\
								 \
								  \(38a45e9)
							</code>
						</pre>
						master branch points to d672e93, and statistics points to 38a45e9. Merge means that git will take common ancestor of both branches (f8e6e63) and will perform so called three-way merge, creating new  merge commit
					</section>
					<section>
						We merge:
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (master) $ git merge statistics
							Merge made by the 'recursive' strategy.
							 stats.c | 1 +
							 1 file changed, 1 insertion(+)
							 create mode 100644 stats.c
							</code>
						</pre>
						In effect git created merge commit (4491d47):
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (master) $ git lg
							*   4491d47 - (2 minutes ago) Merge branch 'statistics' - jedrzej (HEAD -> master)
							|\
							| * 38a45e9 - (17 minutes ago) core statistics file - jedrzej (statistics)
							* | d672e93 - (14 minutes ago) Readme update - jedrzej
							|/
							* f8e6e63 - (2 days ago) Create readme file - jedrzej (origin/master)
							* d12a8a1 - (4 days ago) Initial commit with .gitignore file - jedrzej
							</code>
						</pre>
					</section>
					<section>
						let's revert merge by going 1 commit back:
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (master) $ git reset --hard HEAD~1
							HEAD is now at d672e93 Readme update
							jedrzej@jedrzej-UX303LB ~/presentation (master) $ git lg
							* d672e93 - (20 minutes ago) Readme update - jedrzej (HEAD -> master)
							| * 38a45e9 - (23 minutes ago) core statistics file - jedrzej (statistics)
							|/
							* f8e6e63 - (2 days ago) Create readme file - jedrzej (origin/master)
							* d12a8a1 - (4 days ago) Initial commit with .gitignore file - jedrzej
							</code>
						</pre>
						By the way: HEAD is a pointer that points to most recent commit in current branch.
					</section>
					<section>
						We rebase, which means that we change the base of the statistics branch from previous one to the most recent commit of master
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (master) $ git checkout statistics
							Switched to branch 'statistics'
							~/presentation (statistics) $ git rebase master
							First, rewinding head to replay your work on top of it...
							Applying: core statistics file
							</code>
						</pre>
					</section>
					<section>
						Now our repository looks like this:
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (statistics) $ git lg
							* 1069d35 - (2 days ago) core statistics file - jedrzej (HEAD -> statistics)
							* d672e93 - (2 days ago) Readme update - jedrzej (master)
							* f8e6e63 - (4 days ago) Create readme file - jedrzej (origin/master)
							* d12a8a1 - (6 days ago) Initial commit with .gitignore file - jedrzej
							</code>
						</pre>
						Commit d672e93 became a base for branch statistics. It is worth to note that commit with message
						"core statistics file" changed it's hash from 38a45e9 to 1069d35. Which means that we've altered history of repository.
					</section>
					<section>
						We moved from:
						<pre>
							<code data-trim data-noescape  class="hljs">
							(f8e6e63)------(d672e93)
								\
								 \
								  \(38a45e9)
							</code>
						</pre>
						to:
						<pre>
							<code data-trim data-noescape  class="hljs">
							(f8e6e63)------(d672e93)------(1069d35)
							</code>
						</pre>
					</section>
					<section>
						<p>The history became linear. This might be useful for situations where we are doing something in branch statistics, and simultaneously our colleague is changing master branch in a way that affects our work. And we want to be up to date with his work.</p>
						<p>We can do git pull & git merge couple of times, but then, our history will be full of merge commits that make no sense for external reader</p>
					</section>
					<section>
						Let's do rebase example
					</section>
					<section>
						<pre>
							<code data-trim data-noescape  class="hljs">
								(A)------(B)------(C)------(D)	<-- master
								 \
								  \
								   \(E)------(F)------(G)	<-- feature-branch
							</code>
						</pre>
						<pre>
							<code data-trim data-noescape  class="hljs">
							~/presentation (statistics) $ git rebase master
							</code>
						</pre>
						<pre>
							<code data-trim data-noescape  class="hljs">
								(A)----(B)----(C)----(D)	<-- master
										      \
										       \
										        \(E*)----(F*)----(G*) <-- feature-branch
							</code>
						</pre>
					</section>
					<section>
						<p>Always when we try to push local changes to remote repository but git says that we can'y because on the remote there are changes that we don't have yet.</p>
						<p>what do we do then?</p>
					</section>
					<section>
						<p>We do git pull which actually is git fetch + git merge</p>
						<p>which means that git will take most recent commit of fetched changes, most recent commit of our work, last common commit of those two "branches", and will perform three-way merge, which will result in creating merge commit.</p>
					</section>
					<section>
						The question is:
						<p>Do we really need commits for each such situation?</p>
					</section>
					<section>
						<h1>No</h1>
						<p>what we can do ?</p>
						<p>rebase!</p>
					</section>
					<section>To ilustrate this situation we will:
						<ol>
							<li>create another local repository
							<li>clone remote repository
							<li>commit some changes in master branch
							<li>switch back to previous local repository
							<li>commit some changes
							<li>try to push them (they will be rejected)
							<li>REBASE!!!!!
						</ol>
					</section>
				</section>
				<section data-background="giphy.gif">
				</section>

				<section>Slide 2</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
				slideNumber: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
